const express = require('express');
const { v4: uuidv4 } = require('uuid');

const router = express.Router();
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || 'dev-admin-token';

function requireAdmin(req, res, next) {
  const token = req.headers['x-admin-token'] || req.headers['authorization']?.replace(/^Bearer\s+/i, '');
  if (!token || token !== ADMIN_TOKEN) {
    return res.status(401).json({ error: 'Unauthorized (admin token required)' });
  }
  next();
}

// 弱点問題自動生成関数
async function generateWeaknessProblems(studentName, weaknessTypes) {
  try {
    console.log(`[弱点問題自動生成] 生徒: ${studentName}, 弱点タイプ: ${weaknessTypes.join(', ')}`);
    
    // 各弱点タイプごとに問題を生成
    for (const type of weaknessTypes) {
      const response = await fetch('http://localhost:8000/api/generation/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          level: '3級', // デフォルトレベル、実際は生徒のレベルを取得
          type: type,
          count: 3,
          topics: '',
          customInstructions: `弱点対策用の問題を生成してください。${type}の理解を深めるための基礎的な問題を中心に作成してください。`
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log(`[弱点問題自動生成] ${type} 問題生成完了: ${data.questions.length}問`);
        
        // ここで印刷用HTMLを生成してファイルに保存するか、フロントエンドに通知
        // 今回はログ出力のみ
        console.log(`[弱点問題自動生成] ${type} 問題内容:`, data.questions.map(q => q.content).join('\n'));
      } else {
        console.error(`[弱点問題自動生成] ${type} 問題生成失敗:`, response.status);
      }
    }
  } catch (error) {
    console.error('[弱点問題自動生成] エラー:', error);
  }
}

// メモリ内ストレージ（実際のアプリではデータベースを使用）
let scoreRecords = [];
let qrEvents = [];
let unlockLogs = [];
const scannedQrIds = new Set();

// QRスキャンイベントを記録（POST）
router.post('/qr-scan', (req, res) => {
  try {
    let { eventType, studentId, studentName, questionSetId, questionId, correct, qrId, force } = req.body || {};
    const forceFlag = force === true || force === 'true';
    if (!eventType) {
      return res.status(400).json({ error: 'eventType は必須です' });
    }
    if (forceFlag) {
      const token = req.headers['x-admin-token'] || req.headers['authorization']?.replace(/^Bearer\s+/i, '');
      if (!token || token !== ADMIN_TOKEN) {
        return res.status(401).json({ error: 'Unauthorized (admin token required for force)' });
      }
    }
    if (qrId && !forceFlag) {
      if (scannedQrIds.has(qrId)) {
        return res.status(409).json({ error: 'このQRはすでに読み取り済みです', qrId });
      }
      scannedQrIds.add(qrId);
    }
    const event = {
      id: uuidv4(),
      eventType,
      studentId: studentId || null,
      studentName: studentName || null,
      questionSetId: questionSetId || null,
      questionId: questionId || null,
      correct: typeof correct === 'boolean' ? correct : null,
      scannedAt: new Date(),
      qrId: qrId || null,
      override: !!forceFlag
    };
    qrEvents.push(event);

    // 完了イベント時に簡易弱点推奨を返す（ダミー：最近の誤答タイプを返却）
    if (eventType === 'complete') {
      const recentWrong = scoreRecords
        .filter(r => (studentId ? r.studentId === studentId : true))
        .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))
        .slice(0, 20);
      const byType = {};
      recentWrong.forEach(r => {
        if (!byType[r.type]) byType[r.type] = { total: 0, count: 0 };
        byType[r.type].total += r.score;
        byType[r.type].count += 1;
      });
      const weakTypes = Object.entries(byType)
        .map(([t, v]) => ({ type: t, avg: v.total / v.count }))
        .sort((a, b) => a.avg - b.avg)
        .map(x => x.type)
        .slice(0, 2);

      // 弱点タイプ問題を自動生成（非同期）
      if (weakTypes.length > 0) {
        generateWeaknessProblems(studentName, weakTypes).catch(err => {
          console.error('弱点問題自動生成エラー:', err);
        });
      }

      return res.json({
        message: '完了を受け付けました',
        recommended: weakTypes.length ? weakTypes : ['語彙', '並び替え'],
        autoGenerated: weakTypes.length > 0
      });
    }

    res.status(201).json({ message: 'QRイベントを記録しました', event });
  } catch (error) {
    res.status(500).json({ error: 'QRイベントの記録に失敗しました', message: error.message });
  }
});

// クエリでの簡易スキャン（GET /qr?payload=...）
router.get('/qr', (req, res) => {
  try {
    const { payload } = req.query;
    if (!payload) return res.status(400).json({ error: 'payload がありません' });
    let data = {};
    try { data = JSON.parse(decodeURIComponent(payload)); } catch {}
    const { eventType, studentId, studentName, questionSetId, questionId, correct, qrId, force } = data;
    const forceFlag = force === true || force === 'true';
    if (forceFlag) {
      const token = req.headers['x-admin-token'] || req.headers['authorization']?.replace(/^Bearer\s+/i, '');
      if (!token || token !== ADMIN_TOKEN) {
        return res.status(401).json({ error: 'Unauthorized (admin token required for force)' });
      }
    }
    if (qrId && !forceFlag) {
      if (scannedQrIds.has(qrId)) {
        return res.status(409).json({ error: 'このQRはすでに読み取り済みです', qrId });
      }
      scannedQrIds.add(qrId);
    }
    const event = {
      id: uuidv4(),
      eventType: eventType || 'unknown',
      studentId: studentId || null,
      studentName: studentName || null,
      questionSetId: questionSetId || null,
      questionId: questionId || null,
      correct: typeof correct === 'boolean' ? correct : null,
      scannedAt: new Date(),
      qrId: qrId || null,
      override: !!forceFlag
    };
    qrEvents.push(event);
    res.json({ message: 'QRイベントを記録しました', event });
  } catch (error) {
    res.status(500).json({ error: 'QRイベントの記録に失敗しました', message: error.message });
  }
});

// 全スコア履歴を取得
router.get('/', (req, res) => {
  try {
    const { studentId, level, type, limit = 100, offset = 0 } = req.query;
    
    let filteredRecords = [...scoreRecords];
    
    // フィルタリング
    if (studentId) {
      filteredRecords = filteredRecords.filter(r => r.studentId === studentId);
    }
    if (level) {
      filteredRecords = filteredRecords.filter(r => r.level === level);
    }
    if (type) {
      filteredRecords = filteredRecords.filter(r => r.type === type);
    }
    
    // 日付順でソート
    filteredRecords.sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));
    
    // ページネーション
    const paginatedRecords = filteredRecords.slice(offset, offset + limit);
    
    res.json({
      scoreRecords: paginatedRecords,
      total: filteredRecords.length,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    res.status(500).json({
      error: 'スコア履歴の取得中にエラーが発生しました',
      message: error.message
    });
  }
});

// QRイベント（簡易ログ）一覧
router.get('/qr-events', (req, res) => {
  res.json({ qrEvents });
});

// 教師用: 指定qrIdのロック（既読フラグ）を解除
router.post('/qr/unlock', requireAdmin, (req, res) => {
  try {
    const { qrId } = req.body || {};
    if (!qrId) {
      return res.status(400).json({ error: 'qrId が必要です' });
    }
    if (scannedQrIds.has(qrId)) {
      scannedQrIds.delete(qrId);
      const log = { id: uuidv4(), qrId, unlockedAt: new Date().toISOString() };
      unlockLogs.push(log);
      return res.json({ message: 'QRロックを解除しました', qrId, log });
    }
    return res.status(404).json({ error: '指定のqrIdは記録されていません', qrId });
  } catch (error) {
    res.status(500).json({ error: 'ロック解除に失敗しました', message: error.message });
  }
});

// 教師用: ロック解除履歴
router.get('/qr/unlock-logs', requireAdmin, (req, res) => {
  const { limit = 50 } = req.query;
  const items = unlockLogs.slice(-Number(limit)).reverse();
  res.json({ unlockLogs: items });
});

// 特定のスコア履歴を取得
router.get('/:id', (req, res) => {
  try {
    const { id } = req.params;
    const scoreRecord = scoreRecords.find(r => r.id === id);
    
    if (!scoreRecord) {
      return res.status(404).json({
        error: 'スコア履歴が見つかりません',
        id
      });
    }
    
    res.json(scoreRecord);
  } catch (error) {
    res.status(500).json({
      error: 'スコア履歴の取得中にエラーが発生しました',
      message: error.message
    });
  }
});

// 新しいスコア履歴を作成
router.post('/', (req, res) => {
  try {
    const { 
      studentId, 
      questionSetId, 
      level, 
      type, 
      score, 
      totalQuestions, 
      correctAnswers, 
      timeSpent, 
      answers 
    } = req.body;
    
    // バリデーション
    if (!studentId || !questionSetId || !level || !type || score === undefined) {
      return res.status(400).json({
        error: '必須フィールドが不足しています',
        required: ['studentId', 'questionSetId', 'level', 'type', 'score']
      });
    }
    
    const newScoreRecord = {
      id: uuidv4(),
      studentId,
      questionSetId,
      level,
      type,
      score: parseFloat(score),
      totalQuestions: parseInt(totalQuestions) || 0,
      correctAnswers: parseInt(correctAnswers) || 0,
      timeSpent: parseInt(timeSpent) || 0,
      completedAt: new Date(),
      answers: answers || []
    };
    
    scoreRecords.push(newScoreRecord);
    
    res.status(201).json({
      message: 'スコア履歴が正常に作成されました',
      scoreRecord: newScoreRecord
    });
  } catch (error) {
    res.status(500).json({
      error: 'スコア履歴の作成中にエラーが発生しました',
      message: error.message
    });
  }
});

// スコア履歴を更新
router.put('/:id', (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;
    
    const recordIndex = scoreRecords.findIndex(r => r.id === id);
    
    if (recordIndex === -1) {
      return res.status(404).json({
        error: 'スコア履歴が見つかりません',
        id
      });
    }
    
    // 更新データを適用
    scoreRecords[recordIndex] = {
      ...scoreRecords[recordIndex],
      ...updateData,
      updatedAt: new Date()
    };
    
    res.json({
      message: 'スコア履歴が正常に更新されました',
      scoreRecord: scoreRecords[recordIndex]
    });
  } catch (error) {
    res.status(500).json({
      error: 'スコア履歴の更新中にエラーが発生しました',
      message: error.message
    });
  }
});

// スコア履歴を削除
router.delete('/:id', (req, res) => {
  try {
    const { id } = req.params;
    const recordIndex = scoreRecords.findIndex(r => r.id === id);
    
    if (recordIndex === -1) {
      return res.status(404).json({
        error: 'スコア履歴が見つかりません',
        id
      });
    }
    
    const deletedRecord = scoreRecords.splice(recordIndex, 1)[0];
    
    res.json({
      message: 'スコア履歴が正常に削除されました',
      deletedRecord
    });
  } catch (error) {
    res.status(500).json({
      error: 'スコア履歴の削除中にエラーが発生しました',
      message: error.message
    });
  }
});

// 塾生のスコア統計を取得
router.get('/student/:studentId/stats', (req, res) => {
  try {
    const { studentId } = req.params;
    const { level, type, period } = req.query;
    
    let filteredRecords = scoreRecords.filter(r => r.studentId === studentId);
    
    // フィルタリング
    if (level) {
      filteredRecords = filteredRecords.filter(r => r.level === level);
    }
    if (type) {
      filteredRecords = filteredRecords.filter(r => r.type === type);
    }
    if (period) {
      const now = new Date();
      const periodDays = parseInt(period);
      const cutoffDate = new Date(now.getTime() - (periodDays * 24 * 60 * 60 * 1000));
      filteredRecords = filteredRecords.filter(r => new Date(r.completedAt) >= cutoffDate);
    }
    
    if (filteredRecords.length === 0) {
      return res.json({
        studentId,
        totalRecords: 0,
        averageScore: 0,
        bestScore: 0,
        totalQuestions: 0,
        totalTime: 0,
        byLevel: {},
        byType: {},
        progress: []
      });
    }
    
    // 統計計算
    const totalRecords = filteredRecords.length;
    const averageScore = filteredRecords.reduce((sum, r) => sum + r.score, 0) / totalRecords;
    const bestScore = Math.max(...filteredRecords.map(r => r.score));
    const totalQuestions = filteredRecords.reduce((sum, r) => sum + r.totalQuestions, 0);
    const totalTime = filteredRecords.reduce((sum, r) => sum + r.timeSpent, 0);
    
    // 級別・タイプ別統計
    const byLevel = {};
    const byType = {};
    filteredRecords.forEach(r => {
      byLevel[r.level] = byLevel[r.level] || { count: 0, totalScore: 0, averageScore: 0 };
      byLevel[r.level].count++;
      byLevel[r.level].totalScore += r.score;
      
      byType[r.type] = byType[r.type] || { count: 0, totalScore: 0, averageScore: 0 };
      byType[r.type].count++;
      byType[r.type].totalScore += r.score;
    });
    
    // 平均スコアを計算
    Object.keys(byLevel).forEach(level => {
      byLevel[level].averageScore = byLevel[level].totalScore / byLevel[level].count;
    });
    Object.keys(byType).forEach(type => {
      byType[type].averageScore = byType[type].totalScore / byType[type].count;
    });
    
    // 進捗データ（日付順）
    const progress = filteredRecords
      .sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt))
      .map(r => ({
        date: r.completedAt,
        score: r.score,
        type: r.type,
        level: r.level
      }));
    
    res.json({
      studentId,
      totalRecords,
      averageScore: Math.round(averageScore * 10) / 10,
      bestScore,
      totalQuestions,
      totalTime,
      byLevel,
      byType,
      progress
    });
  } catch (error) {
    res.status(500).json({
      error: 'スコア統計の取得中にエラーが発生しました',
      message: error.message
    });
  }
});

// 弱点分析
router.get('/analysis/weakness/:studentId', (req, res) => {
  try {
    const { studentId } = req.params;
    const { level, type } = req.query;
    
    let filteredRecords = scoreRecords.filter(r => r.studentId === studentId);
    
    if (level) {
      filteredRecords = filteredRecords.filter(r => r.level === level);
    }
    if (type) {
      filteredRecords = filteredRecords.filter(r => r.type === type);
    }
    
    if (filteredRecords.length === 0) {
      return res.json({
        studentId,
        analysis: null,
        message: '分析するデータが不足しています'
      });
    }
    
    // 弱点分析ロジック
    const analysis = {
      studentId,
      level: level || '全級',
      type: type || '全タイプ',
      weakPoints: [],
      recommendedQuestions: [],
      analysisDate: new Date()
    };
    
    // 低スコアの問題タイプを特定
    const typeScores = {};
    filteredRecords.forEach(r => {
      if (!typeScores[r.type]) {
        typeScores[r.type] = { total: 0, count: 0, average: 0 };
      }
      typeScores[r.type].total += r.score;
      typeScores[r.type].count++;
    });
    
    Object.keys(typeScores).forEach(type => {
      typeScores[type].average = typeScores[type].total / typeScores[type].count;
      if (typeScores[type].average < 70) {
        analysis.weakPoints.push(`${type}の理解が不十分`);
      }
    });
    
    // 推奨問題を生成
    if (analysis.weakPoints.length > 0) {
      analysis.recommendedQuestions = [
        '基礎的な問題から始めて段階的に難易度を上げる',
        '間違えた問題の復習を重点的に行う',
        '類似問題を繰り返し解く'
      ];
    }
    
    res.json({ analysis });
  } catch (error) {
    res.status(500).json({
      error: '弱点分析中にエラーが発生しました',
      message: error.message
    });
  }
});

module.exports = router;

